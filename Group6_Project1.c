#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  sonarSensor,    sensorSONAR_cm)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           leftMotor,     tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port2,           armMotor,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          rightMotor,    tmotorVex393_HBridge, openLoop, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Arm Measurements
const float l1 = 0.24;
const float l2 = 0.22;
const float l3 = 0.18;
const float th3 = 50*PI/180;



// data that save the computed objects
const int NUM_POINTS = 500;	// maximum # of positions to collect/compute/save
float data[NUM_POINTS][2];	// the 2D array to save the computed position of the obstacles deteced
int count = 0;			// counter of how many positions computed

const float wheel_radius = 0.034;

typedef struct
{
	float x;    // x-coordinate
	float y;    // y-coordinate
	float yaw;  // orientation
} Vec2;

const int N = 4; // the maximum number of waypoints
float waypoints[N][2] =
{
	{0, 0},
	{0,   0.35},
	{-0.35,    0.35},
	{-0.35,    0},

/* Test Nav
 {0,      0},
	{-0.3,   -0.3},
	{ 0.3,    0.3},
	{-0.3,    0.3},
	{0,        0}
*/
};

void go_straight(float dist, float starting_x, float starting_y, float theta);
void rotate(float angle_of_rotation);
void positionArm(float x_arm, float y_arm, float z_arm);
void moveArm(float arm_angle);
float waypoint_onestep( Vec2 A, Vec2 B );

task main
{

	//positionArm(0.7754,-0.6203,0.1542);
	moveArm(1);

	/*
	Vec2 A, B;				// A and B denote the starting and ending point of each segment, respectively
	A.yaw = PI / 2.0; // the robot's original orientation w.r.t. the positive x-axis (assumed to be 90 degree)

	// loop through each segment
	for( int i = 0; i < N-1; i ++ )
	{
		// get the starting point of each segment
		A.x = waypoints[i][0];
		A.y = waypoints[i][1];

		// get the ending point of each segment
		B.x = waypoints[i+1][0];
		B.y = waypoints[i+1][1];

		A.yaw = waypoint_onestep(A, B);
	}

		//write all saved data into DebugStreem for offline Matlab plotting
	writeDebugStream("\n new trial, waypoints\n");
	// save the waypoints
	for( int i = 0; i < N; i ++ ){
		writeDebugStream("%.4f %.4f\n", waypoints[i][0], waypoints[i][1]);
	}
	writeDebugStream("\n new trial, data\n");
	// save the computed target locations
	for (int i = 0; i < count; i ++){
		writeDebugStream("%.4f %.4f\n", data[i][0], data[i][1]);
	}

	*/
}

// inputs: A stands for the starting point and B stands for the ending point
// A contains its position (A.x and A.y) and orientation (A.yaw)
// B contains its position only (B.x and B.y)
// this function should command the robot to go from position A to position B
// this function should also return the robot's ending orientation (named as angle_at_destination)
// more coding hint: wrap your computed angle_of_rotation to be within [-PI, PI] by:
// if it is greater than PI then minus 2*PI;
// if it is less than -PI then add 2*PI
float waypoint_onestep( Vec2 A, Vec2 B )
{
	// this is the angle (in radians) of a free vector pointing from A to B
	float angle_at_destination = 0;
	angle_at_destination = atan2((B.y-A.y), (B.x-A.x));
	float diff_rotation = angle_at_destination-A.yaw;
	if (diff_rotation > PI) {
		diff_rotation=diff_rotation-2*PI;
	}
	if (diff_rotation < -PI) {
		diff_rotation=diff_rotation+2*PI;
	}

	float distance_to_destination = sqrt(((B.x-A.x)*(B.x-A.x))+((B.y-A.y)*(B.y-A.y))); //distance equation
	rotate(diff_rotation);
	go_straight(distance_to_destination, A.x, A.y, angle_at_destination);
	return angle_at_destination;
}

void go_straight(float dist, float starting_x, float starting_y, float theta)
{
	//Clear the encoders associated with the left and right motors
	nMotorEncoder[rightMotor] = 0;
	nMotorEncoder[leftMotor] = 0;

	float rightEncoder = (dist*360)/(2*PI*wheel_radius);

	//While less than 1000 encoder counts of the right motor
	while(abs(nMotorEncoder[rightMotor]) < rightEncoder)
	{
		if( time1(T1) > 100 & count < NUM_POINTS & SensorValue(sonarSensor) < 100)
		{
    	//////////////////////////   student needs to fill in this portion ////////////////////////////////
    	float d = abs(nMotorEncoder[leftMotor]*2.0*PI*wheel_radius/360.0);
    	float s = SensorValue(sonarSensor) * 0.01;

		//collect sonar data, do necessary computations, and save the computed data into the array ---- data
			data[count][0] = starting_x+(d*cos(theta))+s*(cos(theta-(PI/2)));// your computed x-coordinate of p_3
			data[count][1] = starting_y+(d*sin(theta))+s*(sin(theta-(PI/2)));// your computed y-coordinate of p_3

		 	count ++;
			clearTimer(T1);
		}

		//Move forward at half power
		motor[rightMotor] = 45;
		motor[leftMotor]	= 45;
	}
	motor[rightMotor] = 0;
	motor[leftMotor]	= 0;

}

void translate(float dist)
{
	//Clear the encoders associated with the left and right motors
	nMotorEncoder[rightMotor] = 0;
	nMotorEncoder[leftMotor] = 0;

	float rightEncoder = (dist*360)/(2*PI*wheel_radius);

	//While less than 1000 encoder counts of the right motor
	while(abs(nMotorEncoder[rightMotor]) < rightEncoder)
	{
		if( time1(T1) > 100 & count < NUM_POINTS & SensorValue(sonarSensor) < 100)
		{
    	//////////////////////////   student needs to fill in this portion ////////////////////////////////
    	float d = abs(nMotorEncoder[leftMotor]*2.0*PI*wheel_radius/360.0);
    	float s = SensorValue(sonarSensor) * 0.01;

		 	count ++;
			clearTimer(T1);
		}

		//Move forward at half power
		motor[rightMotor] = 45;
		motor[leftMotor]	= 45;
	}
	motor[rightMotor] = 0;
	motor[leftMotor]	= 0;

}

void moveArm(float arm_angle){

		float startingangle = 0;
		//while (startingangle < arm_angle) {
		motor[armMotor] = 45;
		//startingangle=startingangle+0.1;
	//}

}

void rotate(float angle_of_rotation)
{
	//Clear the encoders associated with the left and right motors
	nMotorEncoder[rightMotor] = 0;
	nMotorEncoder[leftMotor] = 0;

	int ccw;
	int cw;

	float rightEncoderCCW = abs(ccw*angle_of_rotation);
	float rightEncoderCW = abs(cw*angle_of_rotation);

	//While less than 1000 encoder counts of the right motor
	if (angle_of_rotation>=0)
	{
		ccw=300;
		rightEncoderCCW = abs(ccw*angle_of_rotation);
		while(abs(nMotorEncoder[rightMotor]) < rightEncoderCCW)
		{
			//Move CCW at half power
			motor[rightMotor] = 45;
			motor[leftMotor]	= -45;
		}
	}
	if (angle_of_rotation<0)
	{
		cw = 750;
		rightEncoderCW = abs(cw*angle_of_rotation);
		if(angle_of_rotation<=-PI/2)
		{
			cw = 325;
			rightEncoderCW = abs(cw*angle_of_rotation);
		}
		while(abs(nMotorEncoder[rightMotor]) < rightEncoderCW)
		{
			//Move CW at half power
			motor[rightMotor] = -45;
			motor[leftMotor]	= 45;
		}
	}

	motor[rightMotor] = 0;
	motor[leftMotor]	= 0;
}

void positionArm(float x_arm, float y_arm, float z_arm) {
	float k1=l2+l3*cos(th3);
	float k2=l3*sin(th3);
	float k3=z_arm-l1;
	float nk=k3/sqrt(k1*k1+k2*k2);
	float solution_theta1=atan2(Y_arm,x_arm);
	float solution_theta2pos=atan2(k1,k2)+atan2(sqrt(1-nk*nk),nk);
	float solution_theta2neg=atan2(k1,k2)+atan2(-sqrt(1-nk*nk),nk);
	float solution_d2pos=sqrt(x_arm*x_arm+y_arm*y_arm)+k2*sin(solution_theta2pos)-k1*cos(solution_theta2pos);
	float solution_d2neg=sqrt(x_arm*x_arm+y_arm*y_arm)+k2*sin(solution_theta2neg)-k1*cos(solution_theta2neg);

	writeDebugStream("\n Solution Theta1 = ");
	writeDebugStream("%.4f", solution_theta1*180/PI);
	writeDebugStream("\n Solution Theta2 Positive = ");
	writeDebugStream("%.4f", solution_theta2pos*180/PI);
	writeDebugStream("\n Solution Theta2 Negative = ");
	writeDebugStream("%.4f", solution_theta2neg*180/PI);
	writeDebugStream("\n Solution d2 Positive = ");
	writeDebugStream("%.4f", solution_d2pos);
	writeDebugStream("\n Solution d2 Negative = ");
	writeDebugStream("%.4f", solution_d2neg);

	rotate(solution_theta1);
	translate(solution_d2pos);


}
