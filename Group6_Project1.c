#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  sonarSensor,    sensorSONAR_cm)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           leftMotor,     tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port10,          rightMotor,    tmotorVex393_HBridge, openLoop, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// data that save the computed objects
const int NUM_POINTS = 500;	// maximum # of positions to collect/compute/save
float data[NUM_POINTS][2];	// the 2D array to save the computed position of the obstacles deteced
int count = 0;			// counter of how many positions computed


typedef struct
{
	float x;    // x-coordinate
	float y;    // y-coordinate
	float yaw;  // orientation
} Vec2;

const int N = 5; // the maximum number of waypoints
float waypoints[N][2] =
{ {0,      0},
	{-0.3,   -0.3},
	{ 0.3,    0.3},
	{-0.3,    0.3},
	{0,        0}
};

void go_straight(float dist, float starting_x, float starting_y, float theta);
void rotate(float angle_of_rotation);
float waypoint_onestep( Vec2 A, Vec2 B );

task main
{
	

	Vec2 A, B;				// A and B denote the starting and ending point of each segment, respectively
	A.yaw = PI / 2.0; // the robot's original orientation w.r.t. the positive x-axis (assumed to be 90 degree)

	// loop through each segment
	for( int i = 0; i < N-1; i ++ )
	{
		// get the starting point of each segment
		A.x = waypoints[i][0];
		A.y = waypoints[i][1];

		// get the ending point of each segment
		B.x = waypoints[i+1][0];
		B.y = waypoints[i+1][1];

		A.yaw = waypoint_onestep(A, B);
	}
	
}

// inputs: A stands for the starting point and B stands for the ending point
// A contains its position (A.x and A.y) and orientation (A.yaw)
// B contains its position only (B.x and B.y)
// this function should command the robot to go from position A to position B
// this function should also return the robot's ending orientation (named as angle_at_destination)
// more coding hint: wrap your computed angle_of_rotation to be within [-PI, PI] by:
// if it is greater than PI then minus 2*PI;
// if it is less than -PI then add 2*PI
float waypoint_onestep( Vec2 A, Vec2 B )
{
	// this is the angle (in radians) of a free vector pointing from A to B
	float angle_at_destination = 0;
	angle_at_destination = atan2((B.y-A.y), (B.x-A.x));
	float diff_rotation = angle_at_destination-A.yaw;
	if (diff_rotation > PI) {
		diff_rotation=diff_rotation-2*PI;
	}
	if (diff_rotation < -PI) {
		diff_rotation=diff_rotation+2*PI;
	}

	float distance_to_destination = sqrt(((B.x-A.x)*(B.x-A.x))+((B.y-A.y)*(B.y-A.y))); //distance equation
	rotate(diff_rotation);
	go_straight(distance_to_destination, A.x, A.y, angle_at_destination);
	return angle_at_destination;
}

void go_straight(float dist, float starting_x, float starting_y, float theta)
{
	//Clear the encoders associated with the left and right motors
	nMotorEncoder[rightMotor] = 0;
	nMotorEncoder[leftMotor] = 0;

	float rightEncoder = (dist*360)/(2*PI*0.034);

	//While less than 1000 encoder counts of the right motor
	while(abs(nMotorEncoder[rightMotor]) < rightEncoder)
	{
		if( time1(T1) > 100 & count < NUM_POINTS & SensorValue(sonarSensor) < 100)
		{
    	//////////////////////////   student needs to fill in this portion ////////////////////////////////
    	float d = abs((nMotorEncoder[rightMotor]*2*PI*0.034)/360);
    	float s = sonarSensor*100;
		
		//collect sonar data, do necessary computations, and save the computed data into the array ---- data
			data[count][0] = // your computed x-coordinate of p_3
			data[count][1] = // your computed y-coordinate of p_3
		 	count ++;
			clearTimer(T1);
		}

		//Move forward at half power
		motor[rightMotor] = 45;
		motor[leftMotor]	= 45;
	}
	motor[rightMotor] = 0;
	motor[leftMotor]	= 0;

}

void rotate(float angle_of_rotation)
{
	//Clear the encoders associated with the left and right motors
	nMotorEncoder[rightMotor] = 0;
	nMotorEncoder[leftMotor] = 0;

	int ccw;
	int cw;

	float rightEncoderCCW = abs(ccw*angle_of_rotation);
	float rightEncoderCW = abs(cw*angle_of_rotation);

	//While less than 1000 encoder counts of the right motor
	if (angle_of_rotation>=0)
	{
		ccw=300;
		rightEncoderCCW = abs(ccw*angle_of_rotation);
		while(abs(nMotorEncoder[rightMotor]) < rightEncoderCCW)
		{
			//Move CCW at half power
			motor[rightMotor] = 45;
			motor[leftMotor]	= -45;
		}
	}
	if (angle_of_rotation<0)
	{
		cw = 750;
		rightEncoderCW = abs(cw*angle_of_rotation);
		if(angle_of_rotation<=-PI/2)
		{
			cw = 325;
			rightEncoderCW = abs(cw*angle_of_rotation);
		}
		while(abs(nMotorEncoder[rightMotor]) < rightEncoderCW)
		{
			//Move CW at half power
			motor[rightMotor] = -45;
			motor[leftMotor]	= 45;
		}
	}

	motor[rightMotor] = 0;
	motor[leftMotor]	= 0;
}
